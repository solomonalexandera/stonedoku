rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }
    
    function isSuperAdmin() {
      return isSignedIn() && request.auth.token.superAdmin == true;
    }
    
    function isModerator() {
      return isSignedIn() && request.auth.token.moderator == true;
    }

    // User profiles: public readable, writable only by owner
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      // Only allow anonymous accounts to delete themselves (used for guest cleanup).
      allow delete: if isOwner(userId) && request.auth.token.firebase.sign_in_provider == 'anonymous';
    }
    
    // Usernames: used for unique username constraints
    // Creatable by anyone signing up, not updatable or deletable
    match /usernames/{username} {
        allow read: if true; // Public read for availability checks
        // Block reserved usernames (admin, administrator, staff, mod, moderator, support, system, root, superuser, owner)
        // But allow admin- prefix for actual admins
        allow create: if isSignedIn() 
          && request.resource.data.userId == request.auth.uid
          && (username.lower().matches('^admin-.*') || (
            !(username.lower() in ['admin', 'administrator', 'staff', 'mod', 'moderator', 'support', 'system', 'root', 'superuser', 'owner'])
            && !(username.lower().matches('.*admin.*'))
            && !(username.lower().matches('.*staff.*'))
            && !(username.lower().matches('.*moderator.*'))
          ));
        allow update, delete: if false;
    }
    
    // Friends subcollection
    match /users/{userId}/friends/{friendId} {
        allow read: if isSignedIn();
        allow create: if isOwner(userId);
        allow delete: if isOwner(userId) || isOwner(friendId); // Either user can unfriend
    }

    function isRegisteredUser() {
      return isSignedIn() && request.auth.token.email != null;
    }

    // Friend requests (used for consented friendships)
    match /friendRequests/{requestId} {
      allow read: if isSignedIn() && (request.auth.uid == resource.data.fromUid || request.auth.uid == resource.data.toUid);

      // Creation of a pending friend request requires a registered user sender.
      allow create: if isRegisteredUser()
        && request.resource.data.fromUid == request.auth.uid
        && request.resource.data.toUid is string
        && request.resource.data.status == 'pending'
      // Allow the recipient to create a response document (accepted/declined) when necessary
      || (isSignedIn()
        && request.resource.data.toUid == request.auth.uid
        && request.resource.data.fromUid is string
        && request.resource.data.status in ['accepted', 'declined']);

      // Updates: recipient can accept/decline a pending request; sender can cancel.
      allow update: if isSignedIn()
        && (
          (request.auth.uid == resource.data.toUid
            && resource.data.status == 'pending'
            && request.resource.data.status in ['accepted', 'declined'])
          ||
          (request.auth.uid == resource.data.fromUid
            && resource.data.status == 'pending'
            && request.resource.data.status == 'cancelled')
        );

      allow delete: if isSignedIn()
        && (request.auth.uid == resource.data.fromUid || request.auth.uid == resource.data.toUid);
    }

    // Friend removals are a write-only queue that Cloud Functions consumes to
    // symmetrically remove friendships from both user documents.
    match /friendRemovals/{docId} {
      allow create: if isRegisteredUser()
        && request.resource.data.users.size() == 2
        && request.auth.uid in request.resource.data.users;
      allow read, update, delete: if false;
    }

    // Match history - read access for participants
    match /matchHistory/{matchId} {
      allow read: if isSignedIn() && request.auth.uid in resource.data.players;
      allow create: if isSignedIn(); // Could be tightened to functions only
      allow update, delete: if false;
    }

    // Vanity links mapping for registered users
    match /vanityLinks/{username} {
      allow read: if true; // Public read for resolving vanity URLs
      // Creation only allowed by signed-in users with an email (registered users)
      allow create: if isSignedIn() && request.auth.token.email != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // QA reports generated by client-side diagnostics when ?qa=1 is used
    // These are allowed to be created/read by signed-in clients for debugging only
    match /qaReports/{docId} {
      allow create: if isSignedIn();
      allow read: if isSignedIn();
      allow update, delete: if false;
    }

    // Client logs written by the web client for debugging/telemetry
    match /clientLogs/{logId} {
      // Allow clients to create logs while signed in (anonymous or registered)
      allow create: if isSignedIn();
      // Allow admins to read client logs for moderation/diagnostics
      allow read: if isAdmin();
      allow update, delete: if false;
    }

    // Global chat collection (mirrored from RTDB)
    match /globalChat/{messageId} {
      // Public read (anyone can read global chat)
      allow read: if true;
      // Allow signed-in clients (including anonymous) to create messages as themselves
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid
        && request.resource.data.text is string
        && request.resource.data.timestamp != null;
      // Prevent client-side updates/deletes (moderation or functions should handle that)
      allow update, delete: if false;
    }

    // Direct messages (per-conversation subcollection)
    // Participant lists are stored in `dmParticipants/{dmId}` with a `participants` array.
    match /directMessages/{dmId}/messages/{msgId} {
      function dmParticipants() {
        return get(/databases/$(database)/documents/dmParticipants/$(dmId)).data.participants;
      }

      function isParticipant() {
        return isSignedIn() && dmParticipants() is list && request.auth.uid in dmParticipants();
      }

      // Read: only participants or admins can read messages
      allow read: if isParticipant() || isAdmin();

      // Create: sender must be authenticated as `from` field and recipient must be a participant; admins may also create
      allow create: if (isSignedIn()
        && request.resource.data.from == request.auth.uid
        && request.resource.data.to is string
        && request.resource.data.text is string
        && request.resource.data.timestamp != null
        && dmParticipants() is list
        && request.auth.uid in dmParticipants()
        && request.resource.data.to in dmParticipants()) || isAdmin();

      // Admins may update/delete for moderation purposes; participants may not update/delete directly
      allow update, delete: if isAdmin();
    }

    // DM participants mapping (used by security rules to verify participants)
    match /dmParticipants/{dmId} {
      // Create: allow when signed-in user is one of the participants and exactly two participants provided
      // Admins may also create or overwrite participant lists.
      allow create: if (isSignedIn()
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants[0] is string
        && request.resource.data.participants[1] is string) || isAdmin();

      // Read: participants and admins may read
      allow read: if (isSignedIn() && resource.data.participants is list && request.auth.uid in resource.data.participants) || isAdmin();

      // Only admins may update or delete participant documents
      allow update, delete: if isAdmin();
    }

    // Admin allowlist - DEPRECATED: use custom claims instead
    // This collection is no longer used. Custom claims in Firebase Auth
    // handle admin role assignment via Cloud Functions.
    // Kept for backward compatibility only.
    match /admins/{uid} {
      allow read: if isOwner(uid) || isAdmin();
      allow create, update, delete: if false; // Use Cloud Functions instead
    }
    
    // Admin audit log - stores role appointments and admin actions
    match /adminAudit/{logId} {
      // Admins and moderators can read audit logs
      allow read: if isAdmin() || isModerator();
      // Only Cloud Functions can write (no direct client writes)
      allow create, update, delete: if false;
    }

    // Community updates / status feed (public read, write via console/admin tooling)
    match /updates/{updateId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
  }
}
