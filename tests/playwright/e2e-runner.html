<!doctype html>
<html lang="en">
<head><meta charset="utf-8"><title>E2E Runner</title></head>
<body>
<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getAuth, signInAnonymously, signOut, createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile as fbUpdateProfile } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
import { getDatabase, ref, set, get, update, remove, serverTimestamp, goOffline, goOnline } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
import { getFirestore, doc, setDoc, getDoc, enableNetwork, disableNetwork } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

const firebaseConfig = {
    apiKey: "AIzaSyCp7BkBGFmgjSL_28iexOAO7X4RoY_7tQ4",
    authDomain: "stonedoku-c0898.firebaseapp.com",
    projectId: "stonedoku-c0898",
    storageBucket: "stonedoku-c0898.firebasestorage.app",
    messagingSenderId: "755062989426",
    appId: "1:755062989426:web:446a5be32bf4d6b66198eb",
    databaseURL: "https://stonedoku-c0898-default-rtdb.europe-west1.firebasedatabase.app"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const rtdb = getDatabase(app);
const firestore = getFirestore(app);

async function quietConnections() {
  try { goOffline(rtdb); } catch (e) { /* ignore */ }
  try { await disableNetwork(firestore); } catch (e) { /* ignore */ }
}

window.addEventListener('beforeunload', quietConnections);

async function ensureOnline() {
  try { goOnline(rtdb); } catch (e) { /* ignore */ }
  try { await enableNetwork(firestore); } catch (e) { /* ignore */ }
}

window.e2e = {
  signIn: async () => {
    const res = await signInAnonymously(auth);
    return res.user.uid;
  },
  signInWithEmail: async (email, password, displayName) => {
    // Try create account, fall back to sign-in if it already exists
    try {
      const res = await createUserWithEmailAndPassword(auth, email, password);
      if (displayName) {
        try { await fbUpdateProfile(res.user, { displayName }); } catch(_) {}
      }
      return res.user.uid;
    } catch (e) {
      // If already exists, sign in
      try {
        const s = await signInWithEmailAndPassword(auth, email, password);
        return s.user.uid;
      } catch (e2) {
        throw e2;
      }
    }
  },
  signOut: async () => {
    await signOut(auth);
    return true;
  },
  createLobby: async (roomCode, hostUid, otherUid) => {
    await ensureOnline();
    const lobbyRef = ref(rtdb, `lobbies/${roomCode}`);
    const data = {
      host: hostUid,
      playerCount: 2,
      status: 'lobby',
      players: {
        [hostUid]: { name: 'Host' },
        [otherUid]: { name: 'Guest' }
      }
    };
    await set(lobbyRef, data);
    return true;
  },
  readLobby: async (roomCode) => {
    const snap = await get(ref(rtdb, `lobbies/${roomCode}`));
    return snap.exists() ? snap.val() : null;
  },
  createMatch: async (matchId, roomCode, uids) => {
    await ensureOnline();
    const playerIdsObj = {};
    const playersObj = {};
    uids.forEach(u => { playerIdsObj[u] = true; playersObj[u] = { name: 'P' }; });
    const boardState = {};
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) boardState[`${r}_${c}`] = { value: 0, given:false, filledBy: null };
    const matchData = {
      id: matchId,
      roomCode,
      players: playersObj,
      playerIds: playerIdsObj,
      scores: Object.fromEntries(uids.map(u=>[u,0])),
      mistakes: Object.fromEntries(uids.map(u=>[u,0])),
      maxMistakes: 3,
      board: boardState,
      solution: Array(81).fill(0),
      status: 'active',
      startedAt: serverTimestamp()
    };
    await set(ref(rtdb, `matches/${matchId}`), matchData);
    // update lobby
    await update(ref(rtdb, `lobbies/${roomCode}`), { status: 'playing', matchId });
    return true;
  },
    createSinglePlayerMatch: async (matchId, roomCode, uid) => {
      await ensureOnline();
      const playerIdsObj = { [uid]: true };
      const playersObj = { [uid]: { name: 'Solo' } };
      const boardState = {};
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) boardState[`${r}_${c}`] = { value: 0, given:false, filledBy: null };
      const matchData = {
        id: matchId,
        roomCode,
        players: playersObj,
        playerIds: playerIdsObj,
        scores: { [uid]: 0 },
        mistakes: { [uid]: 0 },
        maxMistakes: 3,
        board: boardState,
        solution: Array(81).fill(0),
        status: 'active',
        startedAt: serverTimestamp()
      };
      await set(ref(rtdb, `matches/${matchId}`), matchData);
      await update(ref(rtdb, `lobbies/${roomCode}`), { status: 'playing', matchId });
      return true;
    },
  makeMove: async (matchId, uid, row, col, value) => {
    await ensureOnline();
    const cellRef = ref(rtdb, `matches/${matchId}/board/${row}_${col}`);
    await update(cellRef, { value, filledBy: uid });
    return true;
  },
  readCell: async (matchId, row, col) => {
    await ensureOnline();
    const snap = await get(ref(rtdb, `matches/${matchId}/board/${row}_${col}`));
    return snap.exists() ? snap.val() : null;
  },
  finishMatch: async (matchId) => {
    await ensureOnline();
    await update(ref(rtdb, `matches/${matchId}`), { status: 'finished' });
    return true;
  },
  removePlayerFromLobby: async (roomCode, uid) => {
    try {
      await remove(ref(rtdb, `lobbies/${roomCode}/players/${uid}`));
      return { success: true };
    } catch (e) {
      return { success: false, error: e.message, code: e.code };
    }
  }
  ,
  // Score and rematch helpers
  updateScore: async (matchId, uid, delta) => {
    await ensureOnline();
    const scoreRef = ref(rtdb, `matches/${matchId}/scores/${uid}`);
    const snap = await get(scoreRef);
    const current = snap.exists() ? snap.val() : 0;
    await set(scoreRef, current + delta);
    return true;
  },
  voteRematch: async (roomCode, uid, vote) => {
    await ensureOnline();
    await set(ref(rtdb, `lobbies/${roomCode}/rematchVotes/${uid}`), { vote });
    return true;
  }
  ,
  readScores: async (matchId) => {
    await ensureOnline();
    const snap = await get(ref(rtdb, `matches/${matchId}/scores`));
    return snap.exists() ? snap.val() : null;
  },
  readRematchVotes: async (roomCode) => {
    await ensureOnline();
    const snap = await get(ref(rtdb, `lobbies/${roomCode}/rematchVotes`));
    return snap.exists() ? snap.val() : null;
  }
    ,
    // Firestore profile helpers
  createProfile: async (uid, data) => {
    try {
      await ensureOnline();
      // Mark profiles created by tests so cleanup can identify them
      const payload = Object.assign({}, data || {}, { _e2e: true });
      // Ensure usernameLower mapping for quick lookup in tests
      if (payload.username) payload.usernameLower = String(payload.username).toLowerCase();
      await setDoc(doc(firestore, 'users', uid), payload);
      try {
        if (payload.usernameLower) {
          await setDoc(doc(firestore, 'usernames', payload.usernameLower), { userId: uid });
        }
      } catch (e) { /* ignore mapping failures */ }
      // Quiet connections so later navigations using networkidle aren't held open
      await quietConnections();
      return { success: true };
    } catch (e) {
      return { success: false, error: e.message, code: e.code };
    }
    },
    getProfile: async (uid) => {
      try {
        await ensureOnline();
        const snap = await getDoc(doc(firestore, 'users', uid));
        return snap.exists() ? snap.data() : null;
      } catch (e) {
        return null;
      }
    },
    ensureOnline: async () => { try { await ensureOnline(); return { success: true }; } catch (e) { return { success: false, error: e.message }; } },
    quietConnections: async () => { try { await quietConnections(); return { success: true }; } catch (e) { return { success: false, error: e.message }; } },
    // Global chat (Realtime DB)
  sendGlobalChat: async (uid, displayName, text) => {
      await ensureOnline();
      const id = 'msg_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
      await set(ref(rtdb, `globalChat/${id}`), { userId: uid, displayName, text, timestamp: Date.now() });
      return true;
    },
  readGlobalChat: async () => {
      await ensureOnline();
      const snap = await get(ref(rtdb, `globalChat`));
      return snap.exists() ? snap.val() : null;
    }
    ,
    // Presence helpers for tests
  writePresence: async (uid, displayName) => {
      await ensureOnline();
      try {
        const currentUid = auth.currentUser ? auth.currentUser.uid : uid;
        await set(ref(rtdb, `presence/${currentUid}`), {
          status: 'online',
          displayName: displayName || 'TestUser',
          last_changed: serverTimestamp(),
          current_activity: 'Testing'
        });
        return { success: true, uid: currentUid };
      } catch (e) {
        return { success: false, error: e.message, code: e.code };
      }
    },
  clearPresence: async (uid) => {
      await ensureOnline();
      try {
        const currentUid = auth.currentUser ? auth.currentUser.uid : uid;
        await remove(ref(rtdb, `presence/${currentUid}`));
        return { success: true, uid: currentUid };
      } catch (e) {
        return { success: false, error: e.message, code: e.code };
      }
    }
};

console.log('E2E runner loaded');
</script>
E2E runner loaded
</body>
</html>
